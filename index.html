<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/src/favicon.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vite App</title>
</head>

<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.15/paper-core.js"></script>
  <script type="text/javascript" src="node_modules/paperjs-offset/demo/paperjs-offset.js"></script>

  <button class="tool-button" data-tool-name="toolPath">
    Draw Paths
  </button>

  <button class="tool-button" data-tool-name="toolCircle">
    Stamp Circles
  </button>

  <button class="tool-button" data-tool-name="toolLed">
    Place Leds
  </button>

  <button class="tool-button" data-tool-name="toolSelect">
    Move Points
  </button>

  <canvas resize></canvas>

  <script>

    window.onload = () => {
      // Setup Paper

      paper.setup(document.querySelector('canvas'))


      var topleft = 30;
      var bottomright = 400;



      // Create path.
      var samplePath = new paper.Path({
        segments: [
          [500, 100],
          [600, 100],
          [760, 170],
          [860, 170],
          [520, 250]
        ],
        strokeColor: 'red',
        strokeWidth: 2
      });


      var lineThick = 5;

      var offsetSample = new paper.Group;

      var newOffset = PaperOffset.offset(samplePath, lineThick)
      newOffset.strokeColor = 'black';
      newOffset.strokeWidth = 1;

      offsetSample.addChild(samplePath);
      offsetSample.addChild(newOffset);


      function updatePath() {



        //newOffset = PaperOffset.offset(samplePath, lineThick)

      }




      var moveAmount = 3;


      var globalSelected;


      var selectCircle = new paper.Path.Circle(new paper.Point(600, 600), 10);
      selectCircle.strokeColor = 'black';


      var outpath = new paper.Path();
      outpath.strokeColor = 'rgb(191, 91, 91, 0.5)'
      outpath.add(new paper.Point(topleft, topleft));
      outpath.add(new paper.Point(topleft, bottomright));
      outpath.add(new paper.Point(bottomright, bottomright));
      outpath.add(new paper.Point(bottomright, topleft));
      outpath.closePath();

      //let offset1 = PaperOffset.offset(outpath, 5)
      PaperOffset.offsetStroke(outpath, 5)

      var p4 = new paper.Path();
      p4.strokeColor = 'black';
      p4.add(new paper.Point(51, 81));
      p4.add(new paper.Point(51, 379));
      p4.add(new paper.Point(349, 379));
      p4.closePath();
      p4.fillColor = 'white';

      var p1 = new paper.Path();
      p1.strokeColor = 'black';
      p1.add(new paper.Point(50, 80));
      p1.add(new paper.Point(50, 380));
      p1.add(new paper.Point(350, 380));
      p1.closePath();




      var p3 = new paper.Path();
      p3.strokeColor = 'black';
      p3.add(new paper.Point(51, 51));
      p3.add(new paper.Point(379, 51));
      p3.add(new paper.Point(379, 379));
      p3.closePath();
      p3.fillColor = 'white';

      var p2 = new paper.Path();
      p2.strokeColor = 'black';
      p2.add(new paper.Point(50, 50));
      p2.add(new paper.Point(380, 50));
      p2.add(new paper.Point(380, 380));
      p2.closePath();

      var g1 = new paper.Group([p1, p4]);
      g1.clipped = true;
      g1.children[0].visible = true;
      console.log(g1.children[0])

      var g2 = new paper.Group([p2, p3]);
      g2.clipped = true;

      var leds = new paper.Group();

      //  g1.onMouseEnter = function (event) {
      // this.selected = true;
      // }

      //  g1.onMouseLeave = function (event) {
      // this.selected = false;
      //  }

      //  g2.onMouseEnter = function (event) {
      // this.selected = true;
      //  }

      // g2.onMouseLeave = function (event) {
      // this.selected = false;
      //  }


      function onMouseMove(event) {
        var mouse = event.point;
      }

      var hitOptions = {
        segments: false,
        stroke: false,
        fill: true,
        tolerance: 5
      };

      function onFrame(event) {

      }

      var CornerOptions = {
        segments: true,
        stroke: true,
        fill: false,
        tolerance: 5
      };


      function updateGroupPositions() {
        // update the gr


      }






      function getSelectedThing(item) {

        //if group, get path from group and then reassign "item"

        if (item.getClassName() === 'Group') {
          console.log("this is a group!");
          var childIndex = item.children[0];
          //item.childen[0].selected = true;
          //item = childIndex;
          //console.log(item.id);

          for (var i = 0, l = childIndex.segments.length; i < l; i++) {
            if (childIndex.segments[i].selected) {
              return childIndex.segments[i];
            }
          }
        }


        // Only check curves and segments if item is a path.
        if (item.getClassName() === 'Path') {
          // Check curves.
          for (var i = 0, l = item.curves.length; i < l; i++) {
            if (item.curves[i].selected) {
              return item.curves[i];
            }
          }
          // Check segments.
          for (var i = 0, l = item.segments.length; i < l; i++) {
            if (item.segments[i].selected) {
              return item.segments[i];
            }
          }
        }




        // return item by default.
        return item;
      }



      // Toolstack

      class ToolStack {
        constructor(tools) {
          this.tools = tools.map(tool => tool())
        }

        activateTool(name) {
          const tool = this.tools.find(tool => tool.name === name)
          tool.activate()
        }

        // add more methods here as you see fit ...
      }

      // Tool Path, draws paths on mouse-drag

      const toolPath = () => {
        const tool = new paper.Tool()
        tool.name = 'toolPath'

        let path

        tool.onMouseDown = function (event) {
          path = new paper.Path()
          path.strokeColor = '#424242'
          path.strokeWidth = 4
          path.add(event.point)
        }

        tool.onMouseDrag = function (event) {
          path.add(event.point)
        }

        return tool
      }

      // Tool Circle, draws a 30px circle on mousedown

      const toolCircle = () => {
        const tool = new paper.Tool()
        tool.name = 'toolCircle'

        let path

        tool.onMouseDown = function (event) {
          path = new paper.Path.Circle({
            center: event.point,
            radius: 30,
            fillColor: '#9C27B0'
          })
        }

        return tool
      }

      const toolLed = () => {
        const tool = new paper.Tool()
        tool.name = 'toolLed'

        tool.onMouseDown = function (event) {
          var hitResult = paper.project.hitTest(event.point, hitOptions);
          if (!hitResult)
            return;

          var item = hitResult.item;
          var group = item.parent;

          var newLed = new paper.Path.Circle(event.point, 200);
          group.addChild(newLed);

          var noAlpha = new paper.Color(1, 1, 1, 0);

          var col = new paper.Color(1, 0, 0, 1);
          col.hue = Math.random() * 360;
          col.sat = 1;
          col.brightness = 1;


          newLed.fillColor = {
            gradient: {
              stops: [[col, 0.2], [noAlpha, 1]],
              radial: true
            },
            origin: newLed.position,
            destination: newLed.bounds.rightCenter
          };

          newLed.blendMode = 'multiply';
        }

        return tool
      }

      const toolSelect = () => {
        const tool = new paper.Tool()
        tool.name = 'toolSelect'

        tool.onMouseDown = function (event) {
          // ...only select what was clicked.

          //clear selected from all other objects?
          globalSelected = null;
          paper.project.deselectAll();
          selectCircle.visible = false;



          hit = paper.project.hitTest(event.point, CornerOptions);
          if (hit && hit.location) {
            hit.location.curve.selected = true;
          }
          else if (hit && hit.segment) {
            hit.segment.selected = true;
            globalSelected = paper.project.activeLayer.getItems({ selected: true }).map(getSelectedThing)[0]
            selectCircle.visible = true;
            selectCircle.position = globalSelected.point;
          }

          console.log(globalSelected)
        }


        tool.onMouseDrag = function (event) {
          if (globalSelected != null) {
            globalSelected.point = event.point;
            selectCircle.position = globalSelected.point;
            updatePath();
          }
        }

        tool.onKeyDown = function (event) {

          if (event.key == 'a') {
            globalSelected.point.x -= moveAmount;
          };
          if (event.key == 'd') {
            globalSelected.point.x += moveAmount;
          };
          if (event.key == 'w') {
            globalSelected.point.y -= moveAmount;
          };
          if (event.key == 's') {
            globalSelected.point.y += moveAmount;
          };

          selectCircle.position = globalSelected.point;

        }


        return tool
      }





      // Construct a Toolstack, passing your Tools

      const toolStack = new ToolStack([toolSelect, toolLed, toolPath, toolCircle])

      // Activate a certain Tool

      toolStack.activateTool('toolSelect')

      // Attach click handlers for Tool activation on all
      // DOM buttons with class '.tool-button'

      document.querySelectorAll('.tool-button').forEach(toolBtn => {
        toolBtn.addEventListener('click', e => {
          toolStack.activateTool(e.target.getAttribute('data-tool-name'))
        })
      })
    }


  </script>
</body>

</html>

<style>
  html,
  body,
  canvas {
    width: 100%;
    height: 100%;
    margin: 0;
  }
</style>